# -*- coding: utf-8 -*-
"""
Created on Fri Sep 26 06:58:42 2014

provide interfaces to load the example data files

@author: Sascha Eichstaedt
"""

mfile_examples = ["NetStrat_case.m"]
Excel_examples = ["60.xlsx"]

def loadxl(filename):
    """Load network data information from Excel file as a pandas ExcelFile object
    This methods main aim is to provide a means to access the example_data Excel files.    
    """
    import pandas as pd
    return pd.ExcelFile(filename)
    
    
def load_hdf5(filename):
    """ Load mat-file in hd5 format
    """
    from h5py import File
    return File(filename)


def mat2dict(matfile,variablename,transpose=False):
    """From version 7.x mat-file extract data into Python dict
    This is necessary, because in newer MATLAB versions, mat-files are hdf5 files
    and the required reader returns h5py structures instead of dictionaries
    """
    import h5py
    
    mfile = load_hdf5(matfile)
    try:
        mvar = mfile[variablename]
    except:
        KeyError("Variable %s not found in mat-file"%variablename)

    def save_value(var,curr_key,parent=None):
        if isinstance(parent,str) or isinstance(parent,unicode):
            name = parent + "->" + curr_key
        else:
            name = curr_key        
        if isinstance(var[curr_key],h5py._hl.group.Group):
            new_var = {}
            for key in var[curr_key].keys():
                new_var[key] = save_value(var[curr_key],key,name)
        elif isinstance(var[curr_key],h5py._hl.dataset.Dataset):
            if var[curr_key].shape == (1,1):
                new_var = var[curr_key][0][0]
            else:
                if transpose:
                    new_var = var[curr_key][:].T
                else:
                    new_var = var[curr_key][:]
            print "read " + "."*max(0,(30-len(name))) + name
        return new_var
                
    variables = {}
    for key in mvar.keys():
        variables[key] = save_value(mvar,key)
    print "Converted %s of mat-file %s to dictionary with keys" %(variablename,matfile)
    print variables.keys()
    print "\n"
    return variables
 

def convert_mcase(mfile,pfile=None,adjust_code=True):
    """Convert MatPower case file to PyPower case file
    This method requires the Python module `smop` to be installed.
    """
    import os,sys
    from numpy import asarray,set_printoptions

    try:
        from smop import parse,resolve,backend,options,graphviz
    except ImportError:
        raise ImportError("In order to load m-file cases you have to install the `smop` python module\n")
    
    def is_number(s):
        try:
            int(s)
            return True
        except ValueError:
            return False

    if pfile is None:
        pfile = mfile[:-2]+".py"

 # prepare m-file
    print "Preparing m-file and convert to Python ... "
    newlines = []
    with open(mfile) as f:
        lines = f.readlines()    
        for line in lines:
            if len(line)>1:
                if is_number(line[-2]):
                    line = line[:-1] + ";\n"
            newlines.append(line)
    with open(mfile[:-2]+"_repaired.m","w") as f:
        f.writelines(newlines)                
        mfile = mfile[:-2]+"_repaired.m"
            
 # convert m-file            
    dot = None    
    fp = open(pfile,"w")
    print >> fp, "# Autogenerated with SMOP invoked from"
    print >> fp, "# " + " ".join(sys.argv)
    print >> fp, "from __future__ import division"
    print >> fp, "from numpy import asarray\n\n"

    buf = open(mfile).read().replace("\r\n","\n")
    func_list = parse.parse(buf if buf[-1]=='\n' else buf+'\n',mfile)
    if not func_list and strict:
        sys.exit(-1)
    
    for func_obj in func_list: 
        try:
            func_name = func_obj.head.ident.name
        except AttributeError:
            continue
        fp0 = open("parse_"+func_name+".dot","w") if dot and dot.match(func_name) else None
        if fp0:
            graphviz.graphviz(func_obj,fp0)
        if options.do_resolve:
            resolve.resolve(func_obj)
    
    for func_obj in func_list:
        s = backend.backend(func_obj)
        print >> fp, s
    fp.close()
    
 # adjust Python file    
    set_printoptions(precision=3,threshold=int(1e6),linewidth=5000)
    path = os.getcwd()    
    sys.path.insert(0,path)
    ntab = 4    # number of spaces used for indentation
    space = " "*ntab
   
    if adjust_code:        
        with open(pfile) as f:
            lines = f.readlines()
            new_lines = []
            first = True
            for line in lines:
                if line[ntab:ntab+8]=="varargin" or line[ntab:ntab+6]=="nargin":
                    line = "#" + line
                if line[ntab:ntab+3]=="mpc":
                    if first:
                        new_lines.append(space + "mpc=dict()\n")
                        first = False
                    pos1 = ntab+4
                    pos2 = line.index("=")
                    name = line[pos1:pos2]
                    if line[pos2+1]=="[":
                        print name +"...  ",
                        text = line[pos2+1:-1].replace("\n",";")
                        value = "asarray(\n" + text + ")\n"
                        if name=="bus":
                            bus = eval(value)
                            print bus.shape
                            value = "asarray(\n\t" + repr(bus)[6:] + "\n"
                        elif name=="branch":
                            branch = eval(value)
                            print branch.shape
                            value = "asarray(\n\t" + repr(branch)[6:] + "\n"
                        elif name=="busnames":                        
                            value = line[pos2+1:-1] + "\n"
                            value = value.replace("char(","").replace(")","")
                            val = eval(value)
                            print len(val)                        
                        else:
                            val = eval(value)
                            print val.shape
                            value = "asarray(\n\t"+repr(val)[6:] + "\n"
                    elif line[pos2+1:pos2+5]=="char":
                        value = line[pos2+6:line.index(")")] + "\n"
                    else:
                        value = line[pos2+1:]
                    line = line[:ntab] + 'mpc["%s"]'%name + "=" + value
                new_lines.append(line)
        with open(pfile,"w") as f:
            f.writelines(new_lines)
    print "Done.\nPython case file saved as %s" %(os.path.join(path,pfile))
    

def convert_to_python_indices(casedata):
    """Convert bus indexing in casedata bus, branch and gen to Python indices - range(len(bus)).
    Original indices are stored in casedata["bus_i"]
    """
    from pypower.idx_bus import BUS_I
    from pypower.idx_brch import F_BUS, T_BUS
    from pypower.idx_gen import GEN_BUS
    from numpy import where
    
    orig_inds = casedata["bus"][:,BUS_I].copy()
    casedata["bus_i"] = orig_inds[:]
    
    casedata["bus"][:,BUS_I] = range(len(orig_inds))    
    casedata["gen"][:,GEN_BUS] =  [where(orig_inds==x)[0][0] for x in casedata["gen"][:,GEN_BUS]]
    casedata["branch"][:,F_BUS]=  [where(orig_inds==x)[0][0] for x in casedata["branch"][:,F_BUS]]
    casedata["branch"][:,T_BUS]=  [where(orig_inds==x)[0][0] for x in casedata["branch"][:,T_BUS]]
        

def compare_mat_py(matlab_dict,python_dict,skip=None):
    """Compare MATLAB data (dict) loaded from mat-file to the converted to 
    python dict
    """
    import numpy as np
    
    if skip is None:
        skip = []
    elif isinstance(skip,list):
        skip = list(skip)
    
    def compare_dict(matlab,python,identical,parent=None):
        if not len(matlab.keys())==len(python.keys()):
            print "matlab and python do not have the same number of keys"
            print "matlab dict has keys",
            print matlab.keys()
            print "python dict has keys",
            print python.keys()
            return False
        for key in python.keys():       
            if key in skip:
                continue
            if isinstance(parent,str) or isinstance(parent,unicode):
                name = "%s->%s"%(parent,key)
            else:
                name = "%s"%key
            print "comparing "+ name + "...",
            if isinstance(python[key],dict) and isinstance(matlab[key],dict):
                if isinstance(parent,str):
                    parent = parent + "->%s"%key
                else:
                    parent = "%s"%key
                identical = compare_dict(python[key],matlab[key],identical,parent)
                continue
            if not matlab.has_key(key):
                print "key `%s` found in python but not in matlab"%name,
                identical = False
            if not type(matlab[key])==type(python[key]):
                print "matlab is %s and python is %s"%(type(matlab[key]),type(python[key])),
                identical = False
            if isinstance(matlab[key],np.ndarray):
                if not (matlab[key].shape == python[key].shape):
                    print "matlab has shape %s and python has %s"\
                        %(repr(matlab[key].shape),repr(python[key].shape)),
                    identical = False
            if not np.all(matlab[key] == python[key]):                
                if isinstance(matlab[key],np.ndarray):
                    try:
                        max_err = abs(matlab[key]-python[key]).max()
                        print "..max difference is %g"%max_err,
                    except ValueError:
                        print "`%s` is not identical"%name,
                        
                identical = False 
            print ""
        return identical
            
    identical = compare_dict(matlab_dict,python_dict,True)
    if identical:
        print "Matlab and Python data dicts are identical"
    return identical




